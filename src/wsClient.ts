/**
 * @description This file contains the class WsClient.
 * @file src\wsClient.ts
 * @author Luca Liguori
 * @created 2024-05-01
 * @version 2.0.2
 * @license Apache-2.0
 *
 * Copyright 2024, 2025, 2026 Luca Liguori.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import crypto from 'node:crypto';
import EventEmitter from 'node:events';

import { AnsiLogger, CYAN, LogLevel, TimestampFormat, db, er, hk, nf, rs, wr, zb } from 'matterbridge/logger';
import WebSocket from 'ws';

import { createDigestShellyAuth } from './auth.js';
import { ShellyDevice } from './shellyDevice.js';

interface AuthParams {
  realm: string; // device_id
  username: string; // admin
  nonce: number; // generated by device
  cnonce: number; // random number
  response: string; // hash <<user>:<realm>:<password>> + ":" + <nonce> + ":" + <nc> + ":" + <cnonce> + ":" + "auth" + ":" + <dummy_method:dummy_uri>
  algorithm: string; // SHA-256
}

interface RequestFrame {
  id: number; // Request ID
  src: string; // Source of request
  method: string; // Shelly.GetStatus';
  params: object; // Other parameters
}

interface RequestFrameWithAuth {
  id: number; // Request ID
  src: string; // Source of request
  method: string; // Shelly.GetStatus';
  params: object; // Other parameters
  auth: AuthParams;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface ResponseError {
  id: number;
  src: string;
  dst: string;
  error: {
    code: number;
    message: string;
  };
}

interface ResponseErrorMessage {
  auth_type: string; // digest
  nonce: number;
  nc: number;
  realm: string; // device_id shelly1minig3-543204547478
  algorithm: string; // SHA-256
}

type Params = Record<string, string | number | boolean | object>;

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface ResponseNotifyStatus {
  src: string;
  dst: string;
  method: string;
  params: Params;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface Response {
  id: number;
  src: string;
  dst: string;
  result: Params;
}

interface WsClientEvent {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  response: [response: any];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update: [params: any];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  event: [events: any];
  started: []; // Event emitted when the WebSocket client starts listening for status updates
  stopped: []; // Event emitted when the WebSocket client stops listening for status updates
  open: []; // Event emitted when a WebSocket connection is opened
  close: [code: number, reason: Buffer]; // Event emitted when the WebSocket connection is closed
  error: [message: string]; // Event emitted when an error occurs in the WebSocket client
}

/**
 * WebSocket client for connecting to a Shelly device.
 *
 * @remarks
 * The WsClient class provides methods for establishing a WebSocket connection to a Shelly device,
 * sending requests to the device, and receiving status updates and events from the device.
 * It also includes functionality for handling ping/pong messages to ensure the connection is alive.
 *
 * @example
 * ```typescript
 * const wsClient = new WsClient('shellyplus1-E465B8F3028C', '192.168.1.237', 'password');
 * wsClient.start();
 * wsClient.sendRequest('Shelly.GetStatus');
 * ```
 */
export class WsClient extends EventEmitter<WsClientEvent> {
  public readonly log;
  public static logLevel = LogLevel.INFO;
  private wsClient: WebSocket | undefined;
  private _isConnected = false;
  private _isConnecting = false;
  private id?: string;
  private wsHost;
  private wsDeviceId: string;
  private wsUrl;
  private wsPort = 80; // Default port for WebSocket connections
  private auth = false;
  private password;
  private requestId;

  // PingPong
  private pingInterval?: NodeJS.Timeout;
  private pongTimeout?: NodeJS.Timeout;

  // Define the request frame without auth
  private requestFrame: RequestFrame = {
    id: 0, // Request ID will get updated with a random number
    src: 'Matterbridge', // Source of request
    method: 'Shelly.GetStatus',
    params: {},
  };

  // Define the request frame with auth
  private requestFrameWithAuth: RequestFrameWithAuth = {
    id: 0, // Request ID will get updated with a random number
    src: 'Matterbridge', // Source of request
    method: 'Shelly.GetStatus',
    params: {},
    auth: { realm: '', username: 'admin', nonce: 0, cnonce: 0, response: '', algorithm: 'SHA-256' },
  };

  /**
   * Constructs a new instance of the WsClient class.
   *
   * @param {string} wsDeviceId - The ID of the WebSocket device.
   * @param {string} wsHost - The host of the WebSocket server.
   * @param {number} wsPort - The port of the WebSocket server. Defaults to 80.
   * @param {string} [password] - The optional password for authentication.
   */
  constructor(wsDeviceId: string, wsHost: string, wsPort: number = 80, password?: string) {
    super();
    this.log = new AnsiLogger({ logName: 'ShellyWsClient', logTimestampFormat: TimestampFormat.TIME_MILLIS, logLevel: WsClient.logLevel });
    this.wsHost = wsHost;
    this.wsPort = wsPort;
    this.wsDeviceId = wsDeviceId;
    this.wsUrl = `ws://${this.wsHost}:${this.wsPort}/rpc`;
    this.password = password;
    this.requestId = crypto.randomInt(0, 999999);
    this.requestFrame.id = this.requestId;
    this.requestFrame.src = 'Matterbridge' + this.requestId;
    this.requestFrameWithAuth.id = this.requestId;
    this.requestFrameWithAuth.src = 'Matterbridge' + this.requestId;
  }

  /**
   * Sets the host value for the WebSocket client.
   *
   * @param {string} value - The new host value to set.
   */
  setHost(value: string) {
    this.wsHost = value;
    this.wsUrl = `ws://${this.wsHost}/rpc`;
  }

  /**
   * Gets the connection status of the WebSocket client.
   *
   * @returns {boolean} The connection status of the WebSocket client.
   */
  get isConnected(): boolean {
    return this._isConnected;
  }

  /**
   * Gets the current connection status.
   *
   * @returns {boolean} A boolean value indicating whether the client is currently connecting.
   */
  get isConnecting(): boolean {
    return this._isConnecting;
  }

  /**
   * Sends a request to the WebSocket server.
   *
   * @param {string} method - The method to be passed to the requestFrame. Defaults to 'Shelly.GetStatus'.
   * @param {object} params - The parameters to be passed to the requestFrame. Defaults to an empty object.
   */
  async sendRequest(method: string = 'Shelly.GetStatus', params: Params = {}) {
    if (!this.wsClient || !this._isConnected) {
      this.log.error(`SendRequest error: WebSocket client is not connected to device ${hk}${this.wsDeviceId}${er} host ${zb}${this.wsHost}${er}`);
      return;
    }
    this.requestFrame.method = method;
    this.requestFrame.params = params;
    this.wsClient?.send(JSON.stringify(this.requestFrame));
  }

  /**
   * Starts the PingPong functionality with the specified ping timeout.
   *
   * @param {number} pingTimeout - The timeout value for ping messages in milliseconds. Default is 30000.
   *
   * @remarks
   * This method starts the ping interval and pong timeout.
   */
  private startPingPong(pingTimeout: number = 30000): void {
    this.log.debug(`Start PingPong with device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}.`);
    this.pingInterval = setInterval(() => {
      if (this.wsClient?.readyState === WebSocket.OPEN) {
        this.wsClient.ping(); // Send a ping message

        // Set a timeout to wait for a pong response
        this.pongTimeout = setTimeout(() => {
          this.log.warn(`Pong not received from device ${hk}${this.wsDeviceId}${wr} host ${zb}${this.wsHost}${wr}, closing connection.`);
          this.wsClient?.terminate(); // Close the connection if pong is not received
        }, pingTimeout);
      }
    }, pingTimeout);

    // Listen for pong messages to clear the pong timeout
    this.wsClient?.on('pong', () => {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = undefined;
      this.log.debug(`Pong received from device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}, connection is alive.`);
    });
  }

  /**
   * Stops the PingPong functionality.
   *
   * @remarks
   * This method clears the ping interval and pong timeout if they are set.
   */
  private stopPingPong(): void {
    this.log.debug(`Stop PingPong with device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}.`);
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = undefined;
    }
    if (this.pongTimeout) {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = undefined;
    }
    this.wsClient?.removeAllListeners('pong');
  }

  /**
   * Listens for status updates from the WebSocket connection.
   *
   * @returns {Promise<void>} A promise that resolves when the WebSocket client is ready to listen for status updates.
   *
   * @remarks
   * This method establishes a WebSocket connection and handles various events such as open, error, close, and message.
   * It sends requests and receives responses from the WebSocket server.
   * The received responses are parsed and appropriate actions are taken based on the response type.
   */
  async listenForStatusUpdates(): Promise<void> {
    if (this._isConnecting || this._isConnected) {
      this.log.debug(`WebSocket client is already ${this._isConnecting ? 'connecting' : 'connected'} to device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
      return;
    }
    try {
      this._isConnecting = true;
      this.wsClient = new WebSocket(this.wsUrl);
    } catch (error) {
      this._isConnecting = false;
      this.log.error(`Failed to create WebSocket connection to ${zb}${this.wsUrl}${er}: ${error}`);
      return;
    }

    // Handle the open event
    this.wsClient.on('open', () => {
      this.log.info(`WebSocket connection opened with Shelly device ${hk}${this.wsDeviceId}${nf} host ${zb}${this.wsHost}${nf}`);
      this._isConnecting = false;
      this._isConnected = true;
      if (this.wsClient?.readyState === WebSocket.OPEN) {
        this.log.debug(`Sending request to Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`, this.requestFrame);
        this.wsClient?.send(JSON.stringify(this.requestFrame));
      }

      // Start the ping/pong mechanism
      this.startPingPong();

      // Send the event that the WebSocket is open
      this.emit('open');
    });

    // Handle errors
    this.wsClient.on('error', (error: Error) => {
      this.log.error(`WebSocket error with Shelly device ${hk}${this.wsDeviceId}${er} host ${zb}${this.wsHost}${er}: ${error instanceof Error ? error.message : error}`);
      this._isConnecting = false;
      this.emit('error', error.message);
    });

    // Handle the close event
    this.wsClient.on('close', (code: number, reason: Buffer) => {
      this.log.info(
        `WebSocket connection closed with Shelly device ${hk}${this.wsDeviceId}${nf} host ${zb}${this.wsHost}${nf}: code ${code} ${reason.toString('utf-8') === '' ? '' : 'reason ' + reason.toString('utf-8')}`,
      );
      this._isConnecting = false;
      this._isConnected = false;
      this.stopPingPong();
      this.emit('close', code, reason);
    });

    // Handle messages from the WebSocket
    this.wsClient.on('message', (data: WebSocket.RawData, _isBinary: boolean) => {
      try {
        const response = JSON.parse(data.toString());
        this.id = ShellyDevice.normalizeId(response.src).id;

        // Handle the response error code 401 (auth required)
        if (response.error && response.error.code === 401 && response.id === this.requestId && response.dst === 'Matterbridge' + this.requestId) {
          this.auth = true;
          if (!this.password) {
            this.log.error(`Authentication required for ${response.src} but the password is not set. Exiting...`);
            return;
          }
          this.requestFrameWithAuth.method = this.requestFrame.method;
          this.requestFrameWithAuth.params = this.requestFrame.params;
          const auth: ResponseErrorMessage = JSON.parse(response.error.message);
          this.log.debug(`Auth requested: ${response.error.message}`);
          this.requestFrameWithAuth.auth = createDigestShellyAuth('admin', this.password, auth.nonce, crypto.randomInt(0, 999999999), auth.realm, auth.nc);
          this.log.debug(`Sending auth request to Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`, this.requestFrameWithAuth);
          this.wsClient?.send(JSON.stringify(this.requestFrameWithAuth));
        } else if (response.result && response.id === this.requestId && response.dst === 'Matterbridge' + this.requestId) {
          this.log.debug(`Received ${CYAN}Shelly.GetStatus${db} response from ${hk}${this.id}${db} host ${zb}${this.wsHost}${db}:${rs}\n`, response.result);
          this.emit('response', response.result);
        } else if (response.method && (response.method === 'NotifyStatus' || response.method === 'NotifyFullStatus') && response.dst === 'Matterbridge' + this.requestId) {
          this.log.debug(`Received ${CYAN}${response.method}${db} from ${hk}${this.id}${db} host ${zb}${this.wsHost}${db}:${rs}\n`, response.params);
          this.emit('update', response.params);
        } else if (
          response.method &&
          (response.method === 'NotifyStatus' || response.method === 'NotifyFullStatus') &&
          response.dst === 'user_1' &&
          this.wsDeviceId.startsWith('shellywalldisplay')
        ) {
          this.log.debug(`Received ${CYAN}${response.method}${db} from ${hk}${this.id}${db} host ${zb}${this.wsHost}${db}:${rs}\n`, response.params);
          this.emit('update', response.params);
        } else if (response.method && response.method === 'NotifyEvent' && response.dst === 'Matterbridge' + this.requestId) {
          this.log.debug(`Received ${CYAN}${response.method}${db} from ${hk}${this.id}${db} host ${zb}${this.wsHost}${db}:${rs}\n`, response.params.events);
          this.emit('event', response.params.events);
        } else if (response.method && response.method === 'NotifyEvent' && response.dst === 'user_1' && this.wsDeviceId.startsWith('shellywalldisplay')) {
          this.log.debug(`Received ${CYAN}${response.method}${db} from ${hk}${this.id}${db} host ${zb}${this.wsHost}${db}:${rs}\n`, response.params.events);
          this.emit('event', response.params.events);
        } else if (response.error && response.id === this.requestId && response.dst === 'Matterbridge' + this.requestId) {
          this.log.error(`Received ${CYAN}error response${er} from ${hk}${this.id}${er} host ${zb}${this.wsHost}${er}:${rs}\n`, response);
        } else {
          this.log.debug(`Received ${CYAN}unknown response${db} from ${hk}${this.id}${db} host ${zb}${this.wsHost}${db}:${rs}\n`, response);
        }
      } catch (error) {
        this.log.error(`WebSocket client error parsing message from ${hk}${this.id}${er} host ${zb}${this.wsHost}${er}: ${error instanceof Error ? error.message : error}`);
      }
    });

    // Emit started event
    this.emit('started');
  }

  /**
   * Starts the WebSocket client for the Shelly device.
   *
   * @remarks
   * This method initializes the WebSocket client and starts listening for status updates.
   */
  start() {
    this.log.debug(`Starting ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
    this.listenForStatusUpdates(); // No await to start listening for status updates
    this.log.debug(`Started ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
  }

  /**
   * Stops the WebSocket client for the Shelly device.
   *
   * @remarks
   * This method stops the WebSocket client and performs necessary cleanup operations.
   * If the client is currently connecting, it will wait for a maximum of 5 seconds before forcefully terminating the connection.
   */
  stop() {
    this.log.debug(
      `Stopping ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db} state ${this.wsClient?.readyState} connencting ${this._isConnecting} connected ${this._isConnected} `,
    );
    this.stopPingPong();
    if (!this.wsClient) return;
    // Remved cause we cannot trap the error from websocket.terminate()
    // try {
    if (this.wsClient.readyState === WebSocket.OPEN) {
      this.wsClient.close();
      this.log.debug(`Closed ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
    } else if (this.wsClient.readyState === WebSocket.CONNECTING || this.wsClient.readyState === WebSocket.CLOSING) {
      const wsClient = this.wsClient;
      setTimeout(() => {
        if (wsClient.readyState === WebSocket.OPEN) wsClient.close();
        if (wsClient.readyState === WebSocket.CONNECTING || wsClient.readyState === WebSocket.CLOSING) wsClient.terminate();
      }, 1000).unref();
      this.log.debug(`Terminated ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
    } else if (this.wsClient.readyState === WebSocket.CLOSED) {
      this.log.debug(`Ws client already closed for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
    }
    // } catch (error) {
    // this.log.debug(`Error stopping ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}: ${error}`);
    // } finally {
    this._isConnecting = false;
    this._isConnected = false;
    this.wsClient.removeAllListeners();
    this.wsClient = undefined;
    this.log.debug(`Stopped ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);

    // Emit stopped event
    this.emit('stopped');
    // }
  }
}
