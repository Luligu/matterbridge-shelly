/**
 * This file contains the class WsClient.
 *
 * @file src\wsClient.ts
 * @author Luca Liguori
 * @date 2024-05-01
 * @version 2.0.0
 *
 * Copyright 2024, 2025 Luca Liguori.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. *
 */

import { AnsiLogger, CYAN, LogLevel, TimestampFormat, db, er, hk, nf, rs, wr, zb } from 'matterbridge/logger';
import WebSocket from 'ws';
import crypto from 'crypto';
import EventEmitter from 'events';
import { createDigestShellyAuth } from './auth.js';

interface AuthParams {
  realm: string; // device_id
  username: string; // admin
  nonce: number; // generated by device
  cnonce: number; // random number
  response: string; // hash <<user>:<realm>:<password>> + ":" + <nonce> + ":" + <nc> + ":" + <cnonce> + ":" + "auth" + ":" + <dummy_method:dummy_uri>
  algorithm: string; // SHA-256
}

interface RequestFrame {
  id: number; // Request ID
  src: string; // Source of request
  method: string; // Shelly.GetStatus';
  params: object; // other stuff
}

interface RequestFrameWithAuth {
  id: number; // Request ID
  src: string; // Source of request
  method: string; // Shelly.GetStatus';
  params: object; // other stuff
  auth: AuthParams;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface ResponseError {
  id: number;
  src: string;
  dst: string;
  error: {
    code: number;
    message: string;
  };
}

interface ResponseErrorMessage {
  auth_type: string; // digest
  nonce: number;
  nc: number;
  realm: string; // device_id shelly1minig3-543204547478
  algorithm: string; // SHA-256
}

type Params = Record<string, string | number | boolean | object>;

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface ResponseNotifyStatus {
  src: string;
  dst: string;
  method: string;
  params: Params;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface Response {
  id: number;
  src: string;
  dst: string;
  result: Params;
}

/**
 * WebSocket client for connecting to a Shelly device.
 *
 * @remarks
 * The WsClient class provides methods for establishing a WebSocket connection to a Shelly device,
 * sending requests to the device, and receiving status updates and events from the device.
 * It also includes functionality for handling ping/pong messages to ensure the connection is alive.
 *
 * @example
 * ```typescript
 * const wsClient = new WsClient('shellyplus1-E465B8F3028C', '192.168.1.237', 'password');
 * wsClient.start();
 * wsClient.sendRequest('Shelly.GetStatus');
 * ```
 */
export class WsClient extends EventEmitter {
  public readonly log;
  public static logLevel = LogLevel.INFO;
  private wsClient: WebSocket | undefined;
  private _isConnected = false;
  private _isConnecting = false;
  private id?: string;
  private wsHost;
  private wsDeviceId: string;
  private wsUrl;
  private auth = false;
  private password;
  private requestId;

  // PingPong
  private pingInterval?: NodeJS.Timeout;
  private pongTimeout?: NodeJS.Timeout;
  private stopTimeout?: NodeJS.Timeout;

  // Define the request frame without auth
  private requestFrame: RequestFrame = {
    id: 0, // Request ID will get updated with a random number
    src: 'Matterbridge', // Source of request
    method: 'Shelly.GetStatus',
    params: {},
  };

  // Define the request frame with auth
  private requestFrameWithAuth: RequestFrameWithAuth = {
    id: 0, // Request ID will get updated with a random number
    src: 'Matterbridge', // Source of request
    method: 'Shelly.GetStatus',
    params: {},
    auth: { realm: '', username: 'admin', nonce: 0, cnonce: 0, response: '', algorithm: 'SHA-256' },
  };

  /**
   * Constructs a new instance of the WsClient class.
   *
   * @param {string} wsDeviceId - The ID of the WebSocket device.
   * @param {string} wsHost - The host of the WebSocket server.
   * @param {string} [password] - The optional password for authentication.
   */
  constructor(wsDeviceId: string, wsHost: string, password?: string) {
    super();
    this.log = new AnsiLogger({ logName: 'ShellyWsClient', logTimestampFormat: TimestampFormat.TIME_MILLIS, logLevel: WsClient.logLevel });
    this.wsHost = wsHost;
    this.wsDeviceId = wsDeviceId;
    this.wsUrl = `ws://${this.wsHost}/rpc`;
    this.password = password;
    this.requestId = crypto.randomInt(0, 9999);
    this.requestFrame.id = this.requestId;
    this.requestFrameWithAuth.id = this.requestId;
  }

  /**
   * Gets the connection status of the WebSocket client.
   *
   * @returns {boolean} The connection status of the WebSocket client.
   */
  get isConnected() {
    return this._isConnected;
  }

  /**
   * Gets the current connection status.
   *
   * @returns {boolean} A boolean value indicating whether the client is currently connecting.
   */
  get isConnecting() {
    return this._isConnecting;
  }

  /**
   * Sends a request to the WebSocket server.
   *
   * @param {string} method - The method to be passed to the requestFrame. Defaults to 'Shelly.GetStatus'.
   * @param {object} params - The parameters to be passed to the requestFrame. Defaults to an empty object.
   *
   * @returns void
   */
  async sendRequest(method = 'Shelly.GetStatus', params: Params = {}) {
    if (!this.wsClient || !this._isConnected) {
      this.log.error(`SendRequest error: WebSocket client is not connected to device ${hk}${this.wsDeviceId}${er} host ${zb}${this.wsHost}${er}`);
      return;
    }
    this.requestFrame.method = method;
    this.requestFrame.params = params;
    this.wsClient?.send(JSON.stringify(this.requestFrame));
  }

  /**
   * Starts the PingPong functionality with the specified ping timeout.
   *
   * @remarks
   * This method starts the ping interval and pong timeout.
   *
   * @param {number} pingTimeout - The timeout value for ping messages in milliseconds. Default is 30000.
   *
   * @returns void
   */
  private startPingPong(pingTimeout = 30000) {
    this.log.debug(`Start PingPong with device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}.`);
    this.pingInterval = setInterval(() => {
      if (this.wsClient?.readyState === WebSocket.OPEN) {
        this.wsClient.ping(); // Send a ping message

        // Set a timeout to wait for a pong response
        this.pongTimeout = setTimeout(() => {
          this.log.error(`Pong not received from device ${hk}${this.wsDeviceId}${er} host ${zb}${this.wsHost}${er}, closing connection.`);
          this.wsClient?.terminate(); // Close the connection if pong is not received
        }, pingTimeout);
      }
    }, pingTimeout);

    // Listen for pong messages to clear the pong timeout
    this.wsClient?.on('pong', () => {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = undefined;
      this.log.debug(`Pong received from device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}, connection is alive.`);
    });
  }

  /**
   * Stops the PingPong functionality.
   *
   * @remarks
   * This method clears the ping interval and pong timeout if they are set.
   *
   * @returns void
   */
  private stopPingPong() {
    this.log.debug(`Stop PingPong with device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}.`);
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = undefined;
    }
    if (this.pongTimeout) {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = undefined;
    }
  }

  /**
   * Listens for status updates from the WebSocket connection.
   *
   * @remarks
   * This method establishes a WebSocket connection and handles various events such as open, error, close, and message.
   * It sends requests and receives responses from the WebSocket server.
   * The received responses are parsed and appropriate actions are taken based on the response type.
   *
   * @returns void
   */
  async listenForStatusUpdates() {
    try {
      this._isConnecting = true;
      this.wsClient = new WebSocket(this.wsUrl);
    } catch (error) {
      this.log.error(`Failed to create WebSocket connection to ${zb}${this.wsUrl}${er}: ${error}`);
      return;
    }

    // Handle the open event
    this.wsClient.on('open', () => {
      this.log.debug(`WebSocket connection opened with Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
      this._isConnecting = false;
      this._isConnected = true;
      if (this.wsClient?.readyState === WebSocket.OPEN) this.wsClient?.send(JSON.stringify(this.requestFrame));
      else this.log.error(`WebSocket connection not open with Shelly device ${hk}${this.wsDeviceId}${er} host ${zb}${this.wsHost}${er}`);

      // Start the ping/pong mechanism
      this.startPingPong();
    });

    // Handle errors
    this.wsClient.on('error', (error: Error) => {
      this.log.error(`WebSocket error with Shelly device ${hk}${this.wsDeviceId}${er} host ${zb}${this.wsHost}${rs} readyState: ${this.wsClient?.readyState}\n`, error);
      this._isConnecting = false;
    });

    // Handle the close event
    this.wsClient.on('close', () => {
      this.log.info(`WebSocket connection closed with Shelly device ${hk}${this.wsDeviceId}${nf} host ${zb}${this.wsHost}${nf}`);
      this._isConnected = false;
      this.stopPingPong();
    });

    // Handle messages from the WebSocket
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    this.wsClient.on('message', (data: WebSocket.RawData, isBinary: boolean) => {
      const response = JSON.parse(data.toString());
      this.id = response.src;

      // Handle the response error code 401 (auth required)
      if (response.error && response.error.code === 401 && response.id === this.requestId && response.dst === 'Matterbridge') {
        this.auth = true;
        if (!this.password) {
          this.log.error(`Authentication required for ${response.src} but the password is not set. Exiting...`);
          return;
        }
        this.requestFrameWithAuth.method = this.requestFrame.method;
        this.requestFrameWithAuth.params = this.requestFrame.params;
        const auth: ResponseErrorMessage = JSON.parse(response.error.message);
        this.log.debug(`Auth requested: ${response.error.message}`);
        this.requestFrameWithAuth.auth = createDigestShellyAuth('admin', this.password, auth.nonce, crypto.randomInt(0, 999999999), auth.realm, auth.nc);
        this.wsClient?.send(JSON.stringify(this.requestFrameWithAuth));
      } else if (response.result && response.id === this.requestId && response.dst === 'Matterbridge') {
        this.log.debug(`Received Shelly.GetStatus response from ${CYAN}${this.id}${db} on ${zb}${this.wsHost}${db}:${rs}\n`, response.result);
        this.emit('response', response.result);
      } else if (response.method && (response.method === 'NotifyStatus' || response.method === 'NotifyFullStatus') && response.dst === 'Matterbridge') {
        this.log.debug(`Received NotifyStatus from ${CYAN}${this.id}${db} on ${zb}${this.wsHost}${db}:${rs}\n`, response.params);
        this.emit('update', response.params);
      } else if (response.method && response.method === 'NotifyEvent' && response.dst === 'Matterbridge') {
        this.log.debug(`Received NotifyEvent from ${CYAN}${this.id}${db} on ${zb}${this.wsHost}${db}:${rs}\n`, response.params.events);
        this.emit('event', response.params.events);
      } else if (response.error && response.id === this.requestId && response.dst === 'Matterbridge') {
        this.log.error(`Received error response from ${CYAN}${this.id}${er} on ${zb}${this.wsHost}${er}:${rs}\n`, response);
      } else {
        this.log.warn(`Received unknown response from ${CYAN}${this.id}${wr} on ${zb}${this.wsHost}${wr}:${rs}\n`, response);
      }
    });
  }

  /**
   * Starts the WebSocket client for the Shelly device.
   *
   * @remarks
   * This method initializes the WebSocket client and starts listening for status updates.
   *
   * @returns void
   */
  start() {
    this.log.debug(`Starting ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
    this.listenForStatusUpdates(); // Na await to start listening for status updates
    this.log.debug(`Started ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
  }

  /**
   * Stops the WebSocket client for the Shelly device.
   *
   * @remarks
   * This method stops the WebSocket client and performs necessary cleanup operations.
   * If the client is currently connecting, it will wait for a maximum of 5 seconds before forcefully terminating the connection.
   *
   * @returns void
   */
  stop() {
    this.log.debug(
      `Stopping ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db} state ${this.wsClient?.readyState} connencting ${this._isConnecting} connected ${this._isConnected} `,
    );
    this.stopPingPong();
    if (this._isConnecting) {
      this.stopTimeout = setTimeout(() => {
        this.stopTimeout = undefined;
        if (this._isConnected) this.wsClient?.close();
        if (this._isConnecting) this.wsClient?.terminate();
        this._isConnecting = false;
        this._isConnected = false;
        this.wsClient?.removeAllListeners();
        this.log.debug(`Stopped ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
      }, 5000);
      return;
    }
    if (this._isConnected) this.wsClient?.close();
    this._isConnected = false;
    this.wsClient?.removeAllListeners();
    this.log.debug(`Stopped ws client for Shelly device ${hk}${this.wsDeviceId}${db} host ${zb}${this.wsHost}${db}`);
  }
}

/*
// Start the WebSocket client with the following command: node dist/wsClient.js startWsClient
if (process.argv.includes('startWsClient')) {
  const wsClient1 = new WsClient('192.168.1.217', 'tango');
  wsClient1.start(true);

  const wsClient2 = new WsClient('192.168.1.218', 'tango');
  wsClient2.start(true);

  setTimeout(() => {
    wsClient1.sendRequest('Switch.Set', { id: 0, on: true });
  }, 5000);

  setTimeout(() => {
    wsClient1.sendRequest('Switch.Set', { id: 0, on: false });
  }, 10000);

  setTimeout(() => {
    wsClient1.sendRequest('Shelly.GetComponents', {});
  }, 15000);

  setTimeout(() => {
    wsClient1.sendRequest('Shelly.ListMethods', {});
  }, 20000);

  process.on('SIGINT', async function () {
    wsClient1.stop();
    wsClient2.stop();
  });
}
*/
